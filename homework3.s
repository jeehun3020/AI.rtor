.global arraymax
arraymax:
    // 스택에 필요한 레지스터 저장
    SUBI SP, SP, #16   // 스택에 16 바이트 확보
    STUR LR, [SP, #8]  // 링크 레지스터(LR) 저장
    STUR X19, [SP, #0] // X19 레지스터 저장

    // x0 = 배열의 주소(a), x1 = 요소의 개수(n)
    // 배열이 비어 있는지 체크 및 빈 배열 처리
    CBZ x1, exit1  // n이 0이면, 바로 종료

    // 최대값을 배열의 첫 번째 요소로 초기화
    LDUR x2, [x0]  // x2는 최대값을 저장, a[0]을 x2에 로드
    SUB x1, x1, #1  // 첫 번째 요소를 확인했으므로 n 감소
    CBZ x1, exit1  // n이 1이었다면 종료

    // 루프 인덱스 설정, x19 = 현재 인덱스 (0은 이미 최대값에 있으므로 1부터 시작)
    MOV x19, #1

loop:
    // 다음 요소의 주소 계산 (a[i])
    LSL x4, x19, #3   // x4 = i * 8 (포인터 산술, 각 정수는 8바이트)
    ADD x4, x0, x4    // x4 = a + i*8
    LDUR x5, [x4]     // a[i] 값을 x5에 로드

    // 현재 최대값과 비교하고 새로운 최대값을 찾았다면 업데이트
    SUBS x3, x5, x2   // x5와 x2의 차이를 계산 (x5 - x2)
    B.LE exit2        // x3 <= 0 이면 (즉, x5 <= x2 이면) 다음 반복으로 넘어감
    MOV x2, x5        // 최대값 업데이트

exit2:
    ADD x19, x19, #1  // 인덱스 증가
    SUB x1, x1, #1    // 루프 카운터 감소
    CBZ x1, exit1     // 0이면 완료
    B loop            // 계속 루프

exit1:
    // 최대값을 반환 레지스터로 이동
    MOV x0, x2
    // 스택에서 레지스터 복원
    LDUR X19, [SP, #0]
    LDUR LR, [SP, #8]
    ADDI SP, SP, #16
    BR LR  // 함수 종료 및 반환